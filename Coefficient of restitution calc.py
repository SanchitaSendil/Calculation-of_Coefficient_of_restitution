# -*- coding: utf-8 -*-
"""Portfolio 2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e4l-sn2vwkkD9cHVBVCwXYyMK5bXaNFq

#**UNIVERSITY OF BIRMINGHAM**
#**SCHOOL OF CHEMICAL ENGINEERING**
#**BENG CHEMICAL ENGINEERING FT**


---


#**LDA - 2**
#**0434042**

#**PORTFOLIO 2**


---


#*SANCHITA SENDIL*
#*2430862*
"""

!git clone https://github.com/SanchitaSendil/Portfolio-2-videos.git

import numpy as np
import cv2
import matplotlib.pyplot as plt
def get_circle_centers(video):
    y_list=[] #creating empty array
    frame_indx_lis=[] #creating empty array
    video = cv2.VideoCapture(video)
    fps = video.get(cv2.CAP_PROP_FPS) #finding frames per second
    frame_count = int(video.get(cv2.CAP_PROP_FRAME_COUNT)) # counting the number of frames in the video
    duration = frame_count/fps # duration of video
    print("FPS",fps,"Frame count", frame_count, "Duration",duration,"seconds")
    count=0
    for frame_num in range(frame_count): # for loop for the frames in the video
        # print("Frame count",frame_num)
        ret, frame = video.read()
        if ret:
          gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)# Converting RGB image to Grayscale
          # plt.imshow(gray)
          # crp_img = gray[135:185,75:150]
          blurred = cv2.blur(gray, (5, 5)) # blurring the image
          plt.imshow(blurred)
          circles = cv2.HoughCircles(
                    blurred,
                    cv2.HOUGH_GRADIENT, 1,
                    minDist = 40,
                    param1 = 20, param2 = 40,
                    minRadius = 5, maxRadius=0,#maxradius at zero so all circles are found
                )
          if circles is not None:
            for circ in circles[0]:
              x, y, r = circ
              y_list.append(y) #appending list of y coordinate of centre of circle
              frame_indx_lis.append(frame_num) # appending the list of frame number
              break
              
              
    # Close video
    video.release()
    return y_list, frame_indx_lis

    # Plot the last frame read
    # plt.imshow(gray)

y_list, frame_indx_lis = get_circle_centers("Portfolio-2-videos/1.mp4")

"""# Finding the frame of the video where the ball hits the ground"""

def get_ground_pos(y_list):
    y_shift = np.roll(y_list,-1) #shifts y list by one position to help us find displacement in y coordinates
    y_displacement = (y_list-y_shift) # calculating the dispalcement of the balls center by difference in y coordinates
    #if y_displacement is less than 0 that means the ball is moving downward
    pos_list = list(map(int, y_displacement<0)) #converting Boolean values to 0 or 1
    ground_indx_lis=[] #creating empty array for ground index
    hit_ground = False #flag used to make sure ball has hit the ground
    pos_list_loop_indxs = range(0,len(pos_list)-3,4)#looking at the list in increments of four
    for indx in pos_list_loop_indxs:
      #checking for consecutive ones indicating the ball is moving down
      if pos_list[indx] == 1 and (pos_list[indx+1] == 1  or pos_list[indx+2] == 1 or pos_list[indx+3] == 1):
        hit_ground = False # resetting the flag to say ball already hit ground and is moving up

      #checking for consecutive zeros indicating the bal is moving up  
      if pos_list[indx] == 0 and pos_list[indx+1] == 0  and pos_list[indx+2] == 0 and pos_list[indx+3] == 0 and not hit_ground:
          ground_indx_lis.append(indx-4) #appending ground index list
          hit_ground = True #shows true when ball hits ground

    return ground_indx_lis

ground_indx_lis = get_ground_pos(y_list)
ground_indx_lis

"""### Verifying the functioning of code





"""

grnd_indx = frame_indx_lis[ground_indx_lis[0]]
ground_indx_lis[0]
grnd_indx

"""# Displaying the frame at which the ball hits the ground"""

video = cv2.VideoCapture("Portfolio-2-videos/1.mp4")
video.set(1,grnd_indx)
ret, frame = video.read()
plt.imshow(frame)

"""# Finding the velocity before hitting ground"""

def find_e(ground_indx_lis,y_list):
  step = 1 #number of frames considered for velocity calculation
  ground_y = np.take(y_list, ground_indx_lis) # considering only the frames where ball has hit ground
  prev_step_y = np.array(ground_indx_lis) - step #the point before it has hit the ground
  next_step_y =  np.array(ground_indx_lis) + step #the point after it has hit the ground 

  min_len = min(len(ground_y), len(prev_step_y))#smallest between the two lists is considered to avoid error
  dist_falling = ground_y[:min_len] - prev_step_y[:min_len]
  velocity_falling = dist_falling/(step/30) #calculating velocity of ball before it hits the ground

  min_len = min(len(ground_y), len(next_step_y))
  dist_climbing = ground_y[:min_len] - next_step_y[:min_len]
  velocity_climbing = dist_climbing/(step/30) # calculating velocity of ball after it hits the ground
  e = velocity_climbing/velocity_falling 
  print(e)

e1=find_e(ground_indx_lis,y_list)
e1

"""# Video 2

"""

y_list, frame_indx_lis = get_circle_centers("Portfolio-2-videos/2.mp4")
ground_indx_lis = get_ground_pos(y_list)
ground_indx_lis

e2 = find_e(ground_indx_lis, y_list)
e2

"""# Video 3

"""

y_list, frame_indx_lis = get_circle_centers("Portfolio-2-videos/3.mp4")
ground_indx_lis = get_ground_pos(y_list)
ground_indx_lis
e3 = find_e(ground_indx_lis, y_list)
e3

"""# Video 4

"""

y_list, frame_indx_lis = get_circle_centers("Portfolio-2-videos/4.mp4")
ground_indx_lis = get_ground_pos(y_list)
ground_indx_lis
e4 = find_e(ground_indx_lis, y_list)
e4

"""# Video 5

"""

y_list, frame_indx_lis = get_circle_centers("Portfolio-2-videos/5.mp4")
ground_indx_lis = get_ground_pos(y_list)
ground_indx_lis
e5 = find_e(ground_indx_lis, y_list)
e5

"""# Video 6

"""

y_list, frame_indx_lis = get_circle_centers("Portfolio-2-videos/6.mp4")
ground_indx_lis = get_ground_pos(y_list)
ground_indx_lis
e6 = find_e(ground_indx_lis, y_list)
e6